name: Geox to SRS/MRS

on:
  schedule:
    - cron: '0 23 * * *'
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout codebase
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'
          cache: false

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install Python Dependencies
        run: pip install PyYAML

      - name: Install Tools
        run: |
          set -e

          go install github.com/urlesistiana/v2dat@latest

          SB_LOC="$(curl -fsSLI -o /dev/null -w '%{url_effective}' https://github.com/SagerNet/sing-box/releases/latest)"
          SB_VERSION="$(printf '%s' "$SB_LOC" | sed -n 's#.*/tag/v##p')"
          if [ -z "$SB_VERSION" ]; then
            echo "Failed to detect sing-box version from: $SB_LOC"
            exit 1
          fi
          echo "sing-box version: $SB_VERSION"
          wget -O sing-box.tar.gz "https://github.com/SagerNet/sing-box/releases/download/v${SB_VERSION}/sing-box-${SB_VERSION}-linux-amd64.tar.gz"
          tar -xvf sing-box.tar.gz
          sudo mv sing-box-*/sing-box /usr/local/bin/
          sudo chmod +x /usr/local/bin/sing-box
          sing-box version

          MIHOMO_LOC="$(curl -fsSLI -o /dev/null -w '%{url_effective}' https://github.com/MetaCubeX/mihomo/releases/latest)"
          MIHOMO_TAG="$(printf '%s' "$MIHOMO_LOC" | sed -n 's#.*/tag/##p')"
          if [ -z "$MIHOMO_TAG" ]; then
            echo "Failed to detect mihomo tag from: $MIHOMO_LOC"
            exit 1
          fi
          echo "mihomo tag: $MIHOMO_TAG"
          wget -O mihomo.gz "https://github.com/MetaCubeX/mihomo/releases/download/${MIHOMO_TAG}/mihomo-linux-amd64-${MIHOMO_TAG}.gz"
          gunzip -f mihomo.gz
          sudo mv mihomo /usr/local/bin/
          sudo chmod +x /usr/local/bin/mihomo
          mihomo -v || true

      - name: Download DAT files
        run: |
          set -e
          wget -O geoip.dat https://github.com/Loyalsoldier/v2ray-rules-dat/releases/latest/download/geoip.dat
          wget -O geosite.dat https://github.com/Loyalsoldier/v2ray-rules-dat/releases/latest/download/geosite.dat

      - name: Process and Compile
        shell: python
        run: |
          import os
          import subprocess
          import json
          import yaml
          import shutil

          OUTPUT_DIR = "."
          TEMP_DIR = "temp_extract"

          if os.path.exists(f"{OUTPUT_DIR}/geoip"):
              shutil.rmtree(f"{OUTPUT_DIR}/geoip")
          if os.path.exists(f"{OUTPUT_DIR}/geosite"):
              shutil.rmtree(f"{OUTPUT_DIR}/geosite")

          os.makedirs(f"{OUTPUT_DIR}/geoip", exist_ok=True)
          os.makedirs(f"{OUTPUT_DIR}/geosite", exist_ok=True)

          if os.path.exists(TEMP_DIR):
              shutil.rmtree(TEMP_DIR)
          os.makedirs(f"{TEMP_DIR}/geoip", exist_ok=True)
          os.makedirs(f"{TEMP_DIR}/geosite", exist_ok=True)

          def run_command(cmd: str) -> None:
              print(f"RUN: {cmd}")
              subprocess.run(cmd, shell=True, check=True)

          def strip_clash_prefix(s: str) -> str:
              # Remove Clash-style prefixes that would break sing-box JSON values.
              if "," in s:
                  head, tail = s.split(",", 1)
                  if head in {
                      "DOMAIN", "DOMAIN-SUFFIX", "DOMAIN-REGEX", "DOMAIN-KEYWORD",
                      "IP-CIDR", "IP-CIDR6",
                  }:
                      return tail
              return s

          def is_ipv6_cidr(cidr: str) -> bool:
              # Simple heuristic: IPv6 CIDR contains ':'
              return ":" in cidr

          go_path = subprocess.check_output("go env GOPATH", shell=True).decode().strip()
          v2dat_path = os.path.join(go_path, "bin", "v2dat")

          print("Unpacking geoip.dat...")
          run_command(f"{v2dat_path} unpack geoip geoip.dat -o {TEMP_DIR}/geoip")

          print("Unpacking geosite.dat...")
          run_command(f"{v2dat_path} unpack geosite geosite.dat -o {TEMP_DIR}/geosite")

          def process_category(category_path: str, type_name: str, output_subdir: str) -> None:
              filename = os.path.basename(category_path)
              if filename.startswith(type_name + "_"):
                  rule_name = filename.replace(type_name + "_", "").replace(".txt", "")
              else:
                  rule_name = filename.replace(".txt", "")

              with open(category_path, "r", encoding="utf-8") as f:
                  raw_lines = [line.strip() for line in f if line.strip()]

              # Build Clash/Mihomo payload (.list + .mrs)
              if type_name == "geosite":
                  clash_lines = []
                  for line in raw_lines:
                      if line.startswith("full:"):
                          clash_lines.append(f"DOMAIN,{line[5:]}")
                      elif line.startswith("regexp:"):
                          clash_lines.append(f"DOMAIN-REGEX,{line[7:]}")
                      elif line.startswith("keyword:"):
                          clash_lines.append(f"DOMAIN-KEYWORD,{line[8:]}")
                      elif line.startswith("domain:"):
                          clash_lines.append(f"DOMAIN-SUFFIX,{line[7:]}")
                      else:
                          clash_lines.append(f"DOMAIN-SUFFIX,{line}")
              else:
                  # geoip: use IP-CIDR for IPv4 and IP-CIDR6 for IPv6, otherwise mihomo fails.
                  clash_lines = []
                  for line in raw_lines:
                      cidr = strip_clash_prefix(line)
                      if is_ipv6_cidr(cidr):
                          clash_lines.append(f"IP-CIDR6,{cidr}")
                      else:
                          clash_lines.append(f"IP-CIDR,{cidr}")

              list_path = f"{OUTPUT_DIR}/{output_subdir}/{rule_name}.list"
              with open(list_path, "w", encoding="utf-8") as f:
                  for line in clash_lines:
                      f.write(line + "\n")

              temp_yaml_path = f"{TEMP_DIR}/{rule_name}_temp.yaml"
              with open(temp_yaml_path, "w", encoding="utf-8") as f:
                  yaml.dump({"payload": clash_lines}, f, default_flow_style=False)

              mrs_path = f"{OUTPUT_DIR}/{output_subdir}/{rule_name}.mrs"
              mihomo_type = "domain" if type_name == "geosite" else "ipcidr"
              run_command(f"mihomo convert-ruleset {mihomo_type} yaml {temp_yaml_path} {mrs_path}")
              os.remove(temp_yaml_path)

              # Build sing-box rule-set JSON (.json + .srs)
              if type_name == "geoip":
                  # sing-box expects pure CIDR strings (no IP-CIDR,/IP-CIDR6, prefixes).
                  cidrs = [strip_clash_prefix(x) for x in raw_lines]
                  sb_rules = [{"ip_cidr": cidrs}]
              else:
                  domain_suffix = []
                  domain_full = []
                  domain_regex = []
                  domain_keyword = []

                  for line in raw_lines:
                      line = strip_clash_prefix(line)
                      if line.startswith("full:"):
                          domain_full.append(line[5:])
                      elif line.startswith("regexp:"):
                          domain_regex.append(line[7:])
                      elif line.startswith("domain:"):
                          domain_suffix.append(line[7:])
                      elif line.startswith("keyword:"):
                          domain_keyword.append(line[8:])
                      else:
                          domain_suffix.append(line)

                  rule_item = {}
                  if domain_suffix:
                      rule_item["domain_suffix"] = domain_suffix
                  if domain_full:
                      rule_item["domain"] = domain_full
                  if domain_regex:
                      rule_item["domain_regex"] = domain_regex
                  if domain_keyword:
                      rule_item["domain_keyword"] = domain_keyword

                  sb_rules = [rule_item] if rule_item else []

              sb_json = {"version": 3, "rules": sb_rules}
              json_path = f"{OUTPUT_DIR}/{output_subdir}/{rule_name}.json"
              srs_path = f"{OUTPUT_DIR}/{output_subdir}/{rule_name}.srs"

              with open(json_path, "w", encoding="utf-8") as f:
                  json.dump(sb_json, f, indent=2)

              run_command(f"sing-box rule-set compile --output {srs_path} {json_path}")
              print(f"OK: {type_name}/{rule_name} lines={len(raw_lines)}")

          print("Processing GeoIP files...")
          for f in os.listdir(f"{TEMP_DIR}/geoip"):
              process_category(f"{TEMP_DIR}/geoip/{f}", "geoip", "geoip")

          print("Processing GeoSite files...")
          for f in os.listdir(f"{TEMP_DIR}/geosite"):
              process_category(f"{TEMP_DIR}/geosite/{f}", "geosite", "geosite")

          print("Done!")

      - name: Commit and Push to Main
        run: |
          set -e
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          git add geoip geosite

          if ! git diff --cached --quiet; then
            git commit -m "Update rulesets: $(date +'%Y-%m-%d %H:%M:%S')"
            git push origin HEAD:${{ github.ref }}
          else
            echo "No changes detected, skipping commit."
          fi
